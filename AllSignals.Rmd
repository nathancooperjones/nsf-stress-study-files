---
title: "All Subjects per Sensor per Session"
header-includes:
- \usepackage{booktabs}
- \usepackage{sectsty} \sectionfont{\centering}
output:
  pdf_document: default
  html_document: default
geometry: top=3.5cm, bottom=3cm
---

```{r echo=FALSE, warning = FALSE, message = FALSE, results = "asis"} 
## READ ME FIRST!! 
## You will need to adjust paths for different files. Do a 'find' search for the comment with CHANGE THIS to find areas to change. 
## I have done my best to comment all important blocks of code to ensure you know what they do. 
## Enjoy the script and my attempt at humorous comments! 

# CHANGE THIS 
# Really nothing for you to change here, just wanted to let you know that if you didn't run `SplitSessionAndMergeData.R` first 
# then this script WILL NOT WORK. Don't be foolish - just do it! 

# LIBRARIES - install them if needed, they are all good 
library(tidyverse) 
library(grid) 
library(gridExtra) 
library(scales) 
library(knitr) 
library(kableExtra) 
#install.packages("devtools") 
#devtools::install_github("kassambara/ggpubr") 
library(ggpubr) 
library(XLConnect) 
extrafont::loadfonts(quiet=TRUE) 

# CHANGE THIS 
# Adjust the path to the `nsf-stress-study` directory or else no data and it is sad 
# data_dir <- "~/Desktop/nsf-stress-study" 
data_dir <- "T:/Google Drive/University of Houston/CS - UH/@Research - CPL/@Projects/NsfStressDataCuration/nsf-stress-study"
super_session_pattern <- "^SuperSession$" 

# CHANGE THIS 
# We will also be logging which subjects get filtered out, so ensure you point this to the `log-files` directory you made. 
# log_dir <- file.path('~/Desktop/log-files') 
log_dir <- file.path("T:/Google Drive/University of Houston/CS - UH/@Research - CPL/@Projects/NsfStressDataCuration/log-files") 
filtered_log.file <- file.path(log_dir, paste0('all-signals-filtered-subjects-', format(Sys.Date(), format='%m-%d-%y'), '.txt')) 
invisible(file.create(filtered_log.file)) 

# This is a global tibble that will store everything for us! This is very important for scope reasons you will see later. 
result_df <- tibble() 
# Let's also store some email data. 
emails_df <- tibble() 

# This function tests if a pattern of characters is contained in a string. Pretty neat, but nothing special. 
# I really just made this because I am lazy. Sorry. 
isMatch <- function(pattern, str) { 
  return(grepl(str, pattern)) 
} 





## Okay, welcome to the start of the code! 
# This goes through the directory of `nsf-stress-study` and finds subjects for us to analyze. 
# Specifically, we look for `*_merged.csv` files, which means we have data for a subject. Yay! 
# See `SplitSessionAndMergeData.R` on how this works. 
find_subject_sessions <- function() { 
  
  grp_list <- list.dirs(path=data_dir, full.names=F, recursive=F) 

  # `invisible` so it doesn't print out which subjects succeeded - we already know that by the report idiot! 
  invisible(sapply(grp_list, function(grp_name) { 
    grp_dir <- file.path(data_dir, grp_name) 
    subj_list <- list.dirs(path=grp_dir, full.names=F, recursive=F) 
    
    sapply(subj_list, function(subj_name) { 
      subj_dir <- file.path(grp_dir, subj_name) 
      session_list <- list.dirs(path=subj_dir, full.names=F, recursive=F) 
      session_list_pp <- session_list[grepl(super_session_pattern, session_list, perl = TRUE)] 
      
      sapply(session_list_pp, function(session_name) { 
        session_dir <- file.path(subj_dir, session_name) 
        
        tryCatch({ # in case there are errors in the number of sessions 
          process_the_subject(session_dir, subj_name) 
        }, warning = function(w) { 
          message(paste0("Warnings present for subject ", subj_name, ": ", w, " Continuing process anyway.")) 
          flush.console() 
          return() 
        }, error = function(e) { 
          message(paste0("Error present for subject ", subj_name, ": ", e, " ")) 
          flush.console() 
          return() 
        }) 
      }) 
    }) 
  })) 
} 





## Okay, so now we have found the subject. Now what? 
# We process it. Yay! 
process_the_subject <- function(session_dir, subj_name) { 
  
  # We look for the `.*_merged.csv` file for the subject. 
  pp_file_pattern <- ".*_merged.csv" 
  pp_file_name <- list.files(path=session_dir, pattern=pp_file_pattern, recursive=F) 
  
  # We also look for the `.xlsx` file for extra info, like what Group they are in! 
  subj_interface_file_pattern <- paste0(".*-", subj_name, ".xlsx") 
  subj_interface_file_name <- list.files(path=session_dir, pattern=subj_interface_file_pattern, recursive=F) 
  
  # We ensure we have actually found the file and it is not just `character(0)`. 
  if (length(pp_file_name) == 0 || pp_file_name == "") { 
    stop(paste0("Session file for subject ", subj_name, " is empty. ")) 
  } 
  
  # We can rest assured reading the file in! It reads in as a tibble since they are way more superior to dataframes. 
  df <- read_csv(file.path(session_dir, pp_file_name), col_types = cols()) 
  
  # We factor the Session column so we tell R "Hey! These are different!" 
  # It also makes grouping by them much, much easier. 
  df$Session <- factor(df$Session, levels = c("RestingBaseline", "BaselineWriting", "StressCondition", "DualTask", "Presentation")) 
  
  # Some merged files have no data, so we check it AT LEAST has 5 rows. Or else goodbye! 
  if (nrow(df) < 4) { 
    message(paste0("Dataframe for subject ", subj_name, " is empty. ")) 
    flush.console() 
    return() 
  } 
  
  # Get rid of the 'Time' and 'Perspiration' columns since we simply don't need them, like, at all! 
  df <- df[ , !(names(df) %in% c("Time", "Perspiration"))] 
  
  # We ensure we have uniform data, so we make sure that if a subject doesn't have one of the columns below, 
  # we make it for them and fill it in with just NAs everywhere. Because we are a fair and just people. 
  for (col in c("CovertedTime", "NR_Perspiration", "HR_z", "BR_z", "Session", "EDA_i", "HR_i", "EDA_l", "HR_l", "HR", "EDA")) { 
    if (!(any(names(df) == col))) { 
      df[[col]] <- NA 
    } 
  } 
  
  # We figure out the condition of the subject so we can tell everyone! 
  condition <- NA 
  if (isMatch(subj_interface_file_name, "intermittent-high")) { 
    condition <- "IH" 
  } else if (isMatch(subj_interface_file_name, "batch-high")) { 
    condition <- "BH" 
  } else if (isMatch(subj_interface_file_name, "intermittent-low")) { 
    condition <- "IL" 
  } else if (isMatch(subj_interface_file_name, "batch-low")) { 
    condition <- "BL" 
  } 
  
  # Of course, to actually add this to our global tibble, we need to make sure we record the subject and condition - duh! 
  df$Subject = subj_name 
  df$Condition = condition 
  
  # Add this subject's data to the grand big tibble from the beginning. Note the special '<<-' notation to make changes 
  # to a global object permanent. Everyone says global objects are a bad idea, but I don't care enough to figure out something better. 
  result_df <<- rbind(result_df, df) 
  
  # ADD EMAILS NOW 
  ## EDIT ORDER OF NAMES 
  subj_interface_df <- readWorksheet(XLConnect::loadWorkbook(file.path(session_dir, subj_interface_file_name)), sheet = 'Sheet1') 
  
  email_times_we_want <- c("Email.1.Open.Email.Time", "Email.2.Open.Email.Time", "Email.3.Open.Email.Time", "Email.4.Open.Email.Time", 
                           "Email.5.Open.Email.Time", "Email.6.Open.Email.Time", "Email.7.Open.Email.Time", "Email.8.Open.Email.Time", 
                           "Email.1.Ending.Time", "Email.2.Ending.Time", "Email.3.Ending.Time", "Email.4.Ending.Time", "Email.5.Ending.Time", 
                           "Email.6.Ending.Time", "Email.7.Ending.Time", "Email.8.Ending.Time") 
  
  for (email_time in email_times_we_want) { 
    if (!(email_time %in% names(subj_interface_df))) { 
      subj_interface_df[[email_time]] <- NA 
    } 
  } 
  
  subj_interface_df <- subj_interface_df[1, email_times_we_want] 
  subj_interface_df$Subject <- subj_name 
  
  if (nrow(emails_df) > 0) { 
    emails_df <<- rbind(emails_df, subj_interface_df) 
  } else { 
    emails_df <<- subj_interface_df 
  } 
  
} 





## I named this function circus_wrangler because it wrangles the whole final tibble for us so we have better names. Yay! 
circus_wrangler <- function() { 
  
  # Change the names of the big ol' global tibble so we can access data in a straightforward manner. 
  names(result_df) <<- c("CovertedTime", "PP", "HR", "BR", "Session", "D.EDA", "D.HR", "N.EDA", "N.HR", "HR_bad", "EDA_bad", "Subject", "Condition") 
  
  # We recognize that when a subject says EDA, they mean non-dominant EDA and same for HR. We make sure we update these columns. 
  result_df$N.EDA[is.na(result_df$N.EDA)] <<- result_df$EDA_bad[is.na(result_df$N.EDA)] 
  result_df$N.HR[is.na(result_df$N.HR)] <<- result_df$HR_bad[is.na(result_df$N.HR)] 
  
  # And then we get rid of those columns that we already have covered. Bye bye! 
  result_df <<- result_df[ , !(names(result_df) %in% c("EDA_bad", "HR_bad"))] 
  
} 





## Okay, now that we have processed the subjects, we can finally start the actual script. Wahoo! 
do_the_actual_plotting_now <- function(df, col_name, condition) { 
  
  # See this function below - just makes our graph labels nice and pretty. 
  label <- figure_out_labels(col_name) 
  
  # We make sure we are only plotting for this specific column name and nothing extra, so we just extract the columns we need. 
  df <- result_df[ , c("CovertedTime", "Session", "Subject", "Condition", col_name)] 
  
  # We make sure we have only the one condition foe our plot, get rid of NA values for the column, group by Subject and Session 
  # so we can have each different subject have their own signal for a single session, and then make a Time Elapsed column 
  # using CovertedTime, which is in a POSIX.ct format which allows us to compute time differences. Very sneaky! 
  df <- df %>% 
      filter(Condition == condition) %>% 
      na.omit() %>% 
      group_by(Subject, Session) %>% 
      arrange(CovertedTime) %>% 
      mutate(TimeElapsed = as.integer(CovertedTime) - as.integer(head(CovertedTime, 1))) 
  
  # We can't plot anything if we don't have anything! 
  if (nrow(df) > 0) { 
    
    # Wow, now this is a tricky bug to fix - this makes sure it isn't a factor. Why would it ever be a factor by default? 
    df[[col_name]] <- as.numeric(df[[col_name]]) 
    
    # We now loop through each of the 5 different sessions and do a seperate plot for each. :) 
    sessions <- levels(df$Session) 
    for (sess in sessions) { 
      
      # We figure out the exact session title for this. See this method below. 
      title_sess <- figure_out_session(sess) 
      
      # How many subjects do we have for this measurement for this session? This line below tells us. 
      n <- length(levels(factor((df %>% filter(Session == sess))$Subject))) 
      
      # Okay, I have been typing a lot. Everything in this plot should be pretty self-explanatory. Everything. 
      # If this doesn't make sense, Google it. I am getting lazy. 
      g1 <- df %>% 
        filter(Session == sess) %>% 
        ggplot(aes_string(x = "TimeElapsed", y = col_name, color = "Subject")) + 
          geom_line(alpha = 0.9) + 
          labs(title = paste0(condition, ": ", col_name, " for ", title_sess), 
              subtitle = bquote(list(italic('n')==.(n))), 
              x = "Time [s]", 
              y = label) + 
          theme_bw() + 
          theme(panel.background=element_rect(fill = "NA"), panel.grid.minor = element_line(colour = "#E0E0E0"), 
                plot.title = element_text(size=10)) + 
          scale_x_continuous(breaks = pretty_breaks(n = 4)) 
      
      # Now it is time to filter out subjects! 
      # We do this by making a vector called `bad_subject` and add subjects to it that are poor, then execute them. 
      # Sorry guys. 
      bad_subjects <- NULL 
      filtered_df <- as.data.frame(df) 
      # We add subjects to `bad_subjects` who have signals that hit 0 even once! We are ruthless. 
      bad_subjects <- levels(factor(
        (filtered_df[filtered_df[[col_name]] == 0, ] %>% filter(Session == sess))[ , "Subject"] 
      )) 
      # CHANGE THIS (optional) 
      # Go ahead and add additional subjects, measurements, and sessions that you want to filter out because they are so bad. 
      # Why not! 
      # Subject out of frame 
      if (col_name == "PP" & sess == "StressCondition") { 
        bad_subjects <- c(bad_subjects, "T078") 
      } 
      # Subject out of frame 
      if (col_name == "PP" & sess == "DualTask") { 
        bad_subjects <- c(bad_subjects, "T153") 
      } 
      if (col_name == "PP") { 
        bad_subjects <- c(bad_subjects, "T153") 
      } 
      if (col_name == "PP") { 
        bad_subjects <- c(bad_subjects, "T080", "T081") 
      } 
      
      # And here is the execution, first for out temporary dataframe for plotting... 
      filtered_df <- filtered_df %>% 
        filter(Session == sess & !(Subject %in% bad_subjects)) 
      
      # ... and now for the global tibble. Goodbye bad subjects (they are now NA here)! 
      result_df[result_df$Subject %in% bad_subjects & result_df$Session == sess, col_name] <<- NA 
      
      # We just log our changes so we know who got executed. 
      for (subj_name in bad_subjects) { 
        write(paste0(subj_name, "'s ", col_name, " signal for ", sess, " has been removed. "), file = filtered_log.file, append=TRUE) 
        message(paste0(subj_name, "'s ", col_name, " signal for ", sess, " has been removed. ")) 
      } 
      
      # Still with me? Great! 
      # We now do the same thing as before, but this time with our filtered dataframe without bad subjects. 
      n <- length(levels(factor((filtered_df %>% filter(Session == sess))$Subject))) 
      
      g2 <- filtered_df %>% 
        ggplot(aes_string(x = "TimeElapsed", y = col_name, color = "Subject")) + 
          geom_line(alpha = 0.9) + 
          labs(title = paste0(condition, ": ", col_name, " for ", title_sess, ": Filtered "), 
              subtitle = bquote(list(italic('n')==.(n))), 
              x = "Time [s]", 
              y = label) + 
          theme_bw() + 
          theme(panel.background=element_rect(fill = "NA"), panel.grid.minor = element_line(colour = "#E0E0E0"), 
                plot.title = element_text(size=10)) + 
          scale_x_continuous(breaks = pretty_breaks(n = 4)) 
      
      # We now print the two plots side by side. 
      print(ggarrange(g1, g2, ncol = 2, nrow = 1)) 
      
      # And print a little space between them. 
      cat("  \n    \n    \n  ") 
      
    } 
  } 
} 





# Don't make me explain how this works please. 
figure_out_session <- function(sess) { 
  if (isMatch(sess, 'RestingBaseline')) { 
    return("Resting Baseline") 
  } else if (isMatch(sess, 'BaselineWriting')) { 
    return("Writing Baseline") 
  } else if (isMatch(sess, 'StressCondition')) { 
    return("Stress Condition") 
  } else if (isMatch(sess, 'DualTask')) { 
    return("Dual Task") 
  } 
  return(sess) 
} 





# ... or this one... 
figure_out_labels <- function(col_name) { 
  if (isMatch(col_name, 'PP')) { 
    return(bquote(paste('Perinasal Perspiration [',''^'o','C',''^2,']'))) 
  } else if (isMatch(col_name, 'HR')) { 
    return('Heart Rate [BPM]') 
  } else if (isMatch(col_name, 'BR')) { 
    return('Breathing Rate [BPM]') 
  } else if (isMatch(col_name, 'EDA')) { 
    return(expression(paste('EDA [', mu, 'S]'))) 
  } 
  return('Unknown axis.') 
} 

``` 

```{r echo=FALSE, warning = FALSE, message = FALSE} 
# Whew! We made it! 
# Now we just call the functions we made, sit back, and relax! 
find_subject_sessions() 
circus_wrangler() 
``` 

\newpage  
\vspace*{\fill} 
# Intermittent-High (IH) 
\vspace*{\fill} 
\newpage  
```{r echo = FALSE, warning = FALSE, message = FALSE} 
measurements <- c("PP", "HR", "BR", "D.EDA", "D.HR", "N.EDA", "N.HR") 
condition <- "IH" 
for (measure in measurements) { 
  do_the_actual_plotting_now(result_df, measure, condition) 
} 
``` 

\newpage  
\vspace*{\fill} 
# Intermittent-Low (IL) 
\vspace*{\fill} 
\newpage  
```{r echo = FALSE, warning = FALSE, message = FALSE} 
condition <- "IL" 
for (measure in measurements) { 
  do_the_actual_plotting_now(result_df, measure, condition) 
} 
``` 

\newpage  
\vspace*{\fill} 
# Batch-High (BH) 
\vspace*{\fill} 
\newpage  
```{r echo = FALSE, warning = FALSE, message = FALSE} 
condition <- "BH" 
for (measure in measurements) { 
  do_the_actual_plotting_now(result_df, measure, condition) 
} 
``` 

\newpage  
\vspace*{\fill} 
# Batch-Low (BL) 
\vspace*{\fill} 
\newpage  
```{r echo = FALSE, warning = FALSE, message = FALSE} 
condition <- "BL" 
for (measure in measurements) { 
  do_the_actual_plotting_now(result_df, measure, condition) 
} 
``` 

```{r echo = FALSE, warning = FALSE, message = FALSE} 
# Last but not least, we write this big ol' global tibble to a .csv file so we can access it for every other script we have to run! 

result_df <- result_df[ , c("Subject", "Condition", "Session", "CovertedTime", "PP", "HR", "BR", "D.EDA", "D.HR", "N.EDA", "N.HR")] 
result_df <- result_df %>% 
  group_by(Subject, Session) %>% 
  mutate(TimeElapsed = as.integer(CovertedTime) - as.integer(head(CovertedTime, 1))) 
result_df$Task <- NA 
result_df[result_df$Session == "DualTask", "Task"] <- "Essay" 

subj_list <- levels(factor((emails_df$Subject))) 
for (subject in subj_list) { 

  subj_email_df <- emails_df %>% 
    filter(Subject == subject) 
  
  condition <- as.character(result_df[result_df$Subject == subject, "Condition"][1, 1]) 
  bad_counter <- 0 
  if (condition %in% c("IH", "IL")) { 
    flush.console() 
    for (i in 1:8) { 
      if (is.na(subj_email_df[[i]]) | is.na(subj_email_df[[i + 8]]) | subj_email_df[[i]] == 0 | 
          subj_email_df[[i + 8]] == 0 | subj_email_df[[i]] == subj_email_df[[i + 8]]) { 
        bad_counter <- bad_counter + 1 
        next 
      } 
      result_df[result_df$Subject == subject & result_df$Session == "DualTask" & 
                  subj_email_df[[i]] <= result_df$TimeElapsed & result_df$TimeElapsed <= subj_email_df[[i + 8]], "Task"] <- "Email" 
    } 
    if (bad_counter == 8) { 
      result_df[result_df$Subject == subject & result_df$Session == "DualTask", "Task"] <- NA 
    } 
  } else if (condition %in% c("BH", "BL")) { 
    min_time <- apply(subj_email_df[subj_email_df$Subject == subject, 1:16], 1, FUN = min) 
    max_time <- apply(subj_email_df[subj_email_df$Subject == subject, 1:16], 1, FUN = max) 
    flush.console() 
    if (!is.na(min_time) & !is.na(min_time) & max_time != 0 & min_time != max_time) { 
      result_df[result_df$Subject == subject & result_df$Session == "DualTask" & 
                  min_time <= result_df$TimeElapsed & result_df$TimeElapsed <= max_time, "Task"] <- "Email" 
    } else { 
      result_df[result_df$Subject == subject & result_df$Session == "DualTask", "Task"] <- NA 
    }
  } 
} 

result_df <- result_df[ , c("Subject", "Condition", "Session", "CovertedTime", "TimeElapsed", "PP", "HR", "BR", "D.EDA", "D.HR", "N.EDA", "N.HR", "Task")] 
write.table(result_df, file = "full_df.csv", row.names=F, sep = ',') 
write.table(emails_df, file = "email_df.csv", row.names=F, sep = ',') 
``` 
