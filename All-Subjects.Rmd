---
title: "All Subjects per Sensor per Activity"
header-includes:
- \usepackage{booktabs}
- \usepackage{sectsty} \sectionfont{\centering}
output:
  pdf_document: default
  html_document: default
geometry: top=3.5cm, bottom=3cm
---

```{r echo=FALSE, warning = FALSE, message = FALSE, results = "asis"} 
## READ ME FIRST!! 
## You will need to adjust paths for different files. Do a 'find' search for the comment with CHANGE THIS to find areas to change. 
## I have done my best to comment all important blocks of code to ensure you know what they do. 
## Enjoy the script and my attempt at humorous comments! 

# CHANGE THIS 
# Really nothing for you to change here, just wanted to let you know that if you didn't run `SplitSessionAndMergeData.R` first 
# then this script WILL NOT WORK. Don't be foolish - just do it! 

# LIBRARIES - install them if needed, they are all good 
library(tidyverse) 
library(grid) 
library(gridExtra) 
library(scales) 
library(knitr) 
library(kableExtra) 
#install.packages("devtools") 
#devtools::install_github("kassambara/ggpubr") 
library(ggpubr) 
library(XLConnect) 
extrafont::loadfonts(quiet=TRUE) 

# CHANGE THIS 
# Adjust the path to the `nsf-stress-study` directory or else no data and it is sad 
data_dir <- "~/Desktop/nsf-stress-study" 
# data_dir <- "T:/Google Drive/University of Houston/CS - UH/@Research - CPL/@Projects/NsfStressDataCuration/nsf-stress-study" 
super_session_pattern <- "^SuperSession$" 

# CHANGE THIS 
# Point this to the dataframe generated by `SplitSessionAndMergeData.R`. 
discarded_df <- read_csv("@Datasets/discarded_HR.csv", col_types = cols()) 

# This is a global tibble that will store everything for us! This is very important for scope reasons you will see later. 
result_df <- tibble() 
# Let's also store some email data. 
emails_df <- tibble() 
subject_summary <- tibble() 
subjects_we_filtered <- tibble() 

# This function tests if a pattern of characters is contained in a string. Pretty neat, but nothing special. 
# I really just made this because I am lazy. Sorry. 
isMatch <- function(pattern, str) { 
  return(grepl(str, pattern)) 
} 





## Okay, welcome to the start of the code! 
# This goes through the directory of `nsf-stress-study` and finds subjects for us to analyze. 
# Specifically, we look for `*_merged.csv` files, which means we have data for a subject. Yay! 
# See `SplitSessionAndMergeData.R` on how this works. 
find_subject_sessions <- function() { 
  
  grp_list <- list.dirs(path=data_dir, full.names=F, recursive=F) 

  # `invisible` so it doesn't print out which subjects succeeded - we already know that by the report idiot! 
  invisible(sapply(grp_list, function(grp_name) { 
    grp_dir <- file.path(data_dir, grp_name) 
    subj_list <- list.dirs(path=grp_dir, full.names=F, recursive=F) 
    
    sapply(subj_list, function(subj_name) { 
      subj_dir <- file.path(grp_dir, subj_name) 
      session_list <- list.dirs(path=subj_dir, full.names=F, recursive=F) 
      session_list_pp <- session_list[grepl(super_session_pattern, session_list, perl = TRUE)] 
      
      sapply(session_list_pp, function(session_name) { 
        session_dir <- file.path(subj_dir, session_name) 
        
        tryCatch({ # in case there are errors in the number of sessions 
          process_the_subject(session_dir, subj_name) 
        }, warning = function(w) { 
          message(paste0("Warnings present for subject ", subj_name, ": ", w, " Continuing process anyway.")) 
          flush.console() 
          return() 
        }, error = function(e) { 
          message(paste0("Error present for subject ", subj_name, ": ", e, " ")) 
          flush.console() 
          return() 
        }) 
      }) 
    }) 
  })) 
} 





## Okay, so now we have found the subject. Now what? 
# We process it. Yay! 
process_the_subject <- function(session_dir, subj_name) { 
  
  # We look for the `.*_merged.csv` file for the subject. 
  pp_file_pattern <- ".*_merged.csv" 
  pp_file_name <- list.files(path=session_dir, pattern=pp_file_pattern, recursive=F) 
  
  # We also look for the `.xlsx` file for extra info, like what Group they are in! 
  subj_interface_file_pattern <- paste0(".*-", subj_name, ".xlsx") 
  subj_interface_file_name <- list.files(path=session_dir, pattern=subj_interface_file_pattern, recursive=F) 
  
  # We ensure we have actually found the file and it is not just `character(0)`. 
  if (length(pp_file_name) == 0 || pp_file_name == "") { 
    stop(paste0("Session file for subject ", subj_name, " is empty. ")) 
  } 
  
  # We can rest assured reading the file in! It reads in as a tibble since they are way more superior to dataframes. 
  df <- read_csv(file.path(session_dir, pp_file_name), col_types = cols()) 
  
  # We factor the Session column so we tell R "Hey! These are different!" 
  # It also makes grouping by them much, much easier. 
  df$Session <- factor(df$Session, levels = c("RestingBaseline", "BaselineWriting", "StressCondition", "DualTask", "Presentation")) 
  
  # Some merged files have no data, so we check it AT LEAST has 5 rows. Or else goodbye! 
  if (nrow(df) < 4) { 
    message(paste0("Dataframe for subject ", subj_name, " is empty. ")) 
    flush.console() 
    return() 
  } 
  
  # Get rid of the 'Time' and 'Perspiration' columns since we simply don't need them, like, at all! 
  df <- df[ , !(names(df) %in% c("Time", "Perspiration"))] 
  
  # We ensure we have uniform data, so we make sure that if a subject doesn't have one of the columns below, 
  # we make it for them and fill it in with just NAs everywhere. Because we are a fair and just people. 
  for (col in c("CovertedTime", "NR_Perspiration", "HR_z", "BR_z", "Session", "EDA_i", "HR_i", "EDA_l", "HR_l", "HR", "EDA")) { 
    if (!(any(names(df) == col))) { 
      df[[col]] <- NA 
    } 
  } 
  
  # We figure out the condition of the subject so we can tell everyone! 
  condition <- NA 
  if (isMatch(subj_interface_file_name, "intermittent-high")) { 
    condition <- "IH" 
  } else if (isMatch(subj_interface_file_name, "batch-high")) { 
    condition <- "BH" 
  } else if (isMatch(subj_interface_file_name, "intermittent-low")) { 
    condition <- "IL" 
  } else if (isMatch(subj_interface_file_name, "batch-low")) { 
    condition <- "BL" 
  } 
  
  # Of course, to actually add this to our global tibble, we need to make sure we record the subject and condition - duh! 
  df$Subject = subj_name 
  df$Condition = condition 
  
  # Add this subject's data to the grand big tibble from the beginning. Note the special '<<-' notation to make changes 
  # to a global object permanent. Everyone says global objects are a bad idea, but I don't care enough to figure out something better. 
  result_df <<- rbind(result_df, df) 
  
  # Now we find the email times for the subject! 
  subj_interface_df <- readWorksheet(XLConnect::loadWorkbook(file.path(session_dir, subj_interface_file_name)), sheet = 'Sheet1') 
  
  # We start by renaming the columns to make it way easier to find! 
  email_times_we_want <- c("Email.1.Open.Email.Time", "Email.2.Open.Email.Time", "Email.3.Open.Email.Time", "Email.4.Open.Email.Time", 
                           "Email.5.Open.Email.Time", "Email.6.Open.Email.Time", "Email.7.Open.Email.Time", "Email.8.Open.Email.Time", 
                           "Email.1.Ending.Time", "Email.2.Ending.Time", "Email.3.Ending.Time", "Email.4.Ending.Time", "Email.5.Ending.Time", 
                           "Email.6.Ending.Time", "Email.7.Ending.Time", "Email.8.Ending.Time") 
  
  # We go ahead and make sure that each subject has a column matching each of the above in the `email_times_we_want` vector. If not, 
  # we go ahead and put it there and set it to NA. This makes it so we can `rbind()` all of the subjects' email dataframes together. 
  for (email_time in email_times_we_want) { 
    if (!(email_time %in% names(subj_interface_df))) { 
      subj_interface_df[[email_time]] <- NA 
    } 
  } 
  
  # Take only the first row, but there should only be one row, so this is just a sanity check of sorts I guess. 
  subj_interface_df <- subj_interface_df[1, email_times_we_want] 
  # We add a `Subject` column so we don't get confused... I may have forgot this the first time running this through and, well... 
  # nothing good can come from a dataframe with random data with no connecting bits to it. 
  subj_interface_df$Subject <- subj_name 
  
  # Now we just rbind it to the global `emails_df` tibble and call it a day (until later)! 
  if (nrow(emails_df) > 0) { 
    emails_df <<- rbind(emails_df, subj_interface_df) 
  } else { 
    emails_df <<- subj_interface_df 
  } 
} 





## I named this function circus_wrangler because it wrangles the whole final tibble for us so we have better names. Yay! 
circus_wrangler <- function() { 
  
  # Change the names of the big ol' global tibble so we can access data in a straightforward manner. 
  names(result_df) <<- c("CovertedTime", "PP", "HR", "BR", "Session", "D.EDA", "D.HR", "N.EDA", "N.HR", "HR_bad", "EDA_bad", "Subject", "Condition") 
  
  # We recognize that when a subject says EDA, they mean non-dominant EDA and same for HR. We make sure we update these columns. 
  result_df$N.EDA[is.na(result_df$N.EDA)] <<- result_df$EDA_bad[is.na(result_df$N.EDA)] 
  result_df$N.HR[is.na(result_df$N.HR)] <<- result_df$HR_bad[is.na(result_df$N.HR)] 
  
  # And then we get rid of those columns that we already have covered. Bye bye! 
  result_df <<- result_df[ , !(names(result_df) %in% c("EDA_bad", "HR_bad"))] 
  
} 





## Okay, now that we have processed the subjects, we can finally start the actual script. Wahoo! 
do_the_actual_plotting_now <- function(df, col_name, condition) { 
  
  # See this function below - just makes our graph labels nice and pretty. 
  label <- figure_out_labels(col_name) 
  
  # We make sure we are only plotting for this specific column name and nothing extra, so we just extract the columns we need. 
  df <- result_df[ , c("CovertedTime", "Session", "Subject", "Condition", col_name)] 
  
  # We make sure we have only the one condition foe our plot, get rid of NA values for the column, group by Subject and Session 
  # so we can have each different subject have their own signal for a single session, and then make a Time Elapsed column 
  # using CovertedTime, which is in a POSIX.ct format which allows us to compute time differences. Very sneaky! 
  df <- df %>% 
      filter(Condition == condition) %>% 
      na.omit() %>% 
      group_by(Subject, Session) %>% 
      arrange(CovertedTime) %>% 
      mutate(TimeElapsed = as.integer(CovertedTime) - as.integer(head(CovertedTime, 1))) 
  
  # We can't plot anything if we don't have anything! 
  if (nrow(df) > 0) { 
    
    # Wow, now this is a tricky bug to fix - this makes sure it isn't a factor. Why would it ever be a factor by default? 
    df[[col_name]] <- as.numeric(df[[col_name]]) 
    
    # We now loop through each of the 5 different sessions and do a seperate plot for each. :) 
    sessions <- levels(df$Session) 
    for (sess in sessions) { 
      
      # We figure out the exact session title for this. See this method below. 
      title_sess <- figure_out_session(sess) 
      
      # How many subjects do we have for this measurement for this session? This line below tells us. 
      n <- length(levels(factor((df %>% filter(Session == sess))$Subject))) 
      
      # Okay, I have been typing a lot. Everything in this plot should be pretty self-explanatory. Everything. 
      # If this doesn't make sense, Google it. I am getting lazy. 
      g1 <- df %>% 
        filter(Session == sess) %>% 
        ggplot(aes_string(x = "TimeElapsed", y = col_name, color = "Subject")) + 
          geom_line(alpha = 0.9) + 
          labs(title = paste0(get_condition(condition), ": ", col_name, " for ", title_sess), 
              subtitle = bquote(list(italic('n')==.(n))), 
              x = "Time [s]", 
              y = label) + 
          theme_bw() + 
          theme(panel.background=element_rect(fill = "NA"), panel.grid.minor = element_line(colour = "#E0E0E0"), 
                plot.title = element_text(size=10)) + 
          scale_x_continuous(breaks = pretty_breaks(n = 4)) 
      
      # Now it is time to filter out subjects! 
      # We do this by making a vector called `bad_subject` and add subjects to it that are poor, then execute them. 
      # Sorry guys. 
      bad_subjects <- NULL 
      filtered_df <- as.data.frame(df) 
      # We add subjects to `bad_subjects` who have signals that hit 0 even once! We are ruthless. 
      bad_subjects <- levels(factor(
        (filtered_df[filtered_df[[col_name]] == 0, ] %>% filter(Session == sess))[ , "Subject"] 
      )) 
      # CHANGE THIS (optional) 
      # Go ahead and add additional subjects, measurements, and sessions that you want to filter out because they are so bad. 
      # Why not! 
      # Subject out of frame 
      
      
      # if (col_name == "PP" & condition == "BH" & sess == "StressCondition") {
      #   bad_subjects <- c(bad_subjects, "T078")
      # }
      # if (col_name == "PP" & condition == "IH" & sess == "StressCondition") {
      #   bad_subjects <- c(bad_subjects, "T064")
      # }
      # if (col_name == "PP" & condition == "IL") {
      #   bad_subjects <- c(bad_subjects, "T153")
      # }
      # if (col_name == "PP" & condition == "BH") {
      #   bad_subjects <- c(bad_subjects, "T080")
      # }
      # if (col_name == "PP" & condition == "BH") {
      #   bad_subjects <- c(bad_subjects, "T173")
      # }
      # if (col_name == "PP" & condition == "IH") {
      #   bad_subjects <- c(bad_subjects, "T126")
      # }
      # if (col_name == "PP" & condition == "IL") {
      #   bad_subjects <- c(bad_subjects, "T097")
      # }
      # if (col_name == "PP" & condition == "IL") {
      #   bad_subjects <- c(bad_subjects, "T093")
      # }
      # if (col_name == "PP" & condition == "BH") {
      #   bad_subjects <- c(bad_subjects, "T136")
      # }
      # if (col_name == "PP" & condition == "BL") {
      #   bad_subjects <- c(bad_subjects, "T173")
      # }
      # if (col_name == "PP" & condition == "BL") {
      #   bad_subjects <- c(bad_subjects, "T108")
      # }
      
      
 
      # if (col_name == "PP") { 
      #   bad_subjects <- c(bad_subjects, "T081") 
      # }


      
      # And here is the execution, first for out temporary dataframe for plotting... 
      filtered_df <- filtered_df %>% 
        filter(Session == sess & !(Subject %in% bad_subjects)) 
        
      filtered_subject <- tibble("Subject" = bad_subjects, "Session" = sess, "Measure" = col_name) 
      if (nrow(subjects_we_filtered) > 0) { 
        subjects_we_filtered <<- rbind(subjects_we_filtered, filtered_subject) 
      } else { 
        subjects_we_filtered <<- filtered_subject 
      } 
      
      # ... and now for the global tibble. Goodbye bad subjects (they are now NA here)! 
      result_df[result_df$Subject %in% bad_subjects & result_df$Session == sess, col_name] <<- NA 
      
      # We just message our changes so we know who got executed. 
      for (subj_name in bad_subjects) { 
        message(paste0(subj_name, "'s ", col_name, " signal for ", sess, " has been removed. ")) 
      } 
      
      # Still with me? Great! 
      # We now do the same thing as before, but this time with our filtered dataframe without bad subjects. 
      n <- length(levels(factor((filtered_df %>% filter(Session == sess))$Subject))) 
      
      g2 <- filtered_df %>% 
        ggplot(aes_string(x = "TimeElapsed", y = col_name, color = "Subject")) + 
          geom_line(alpha = 0.9) + 
          labs(title = paste0(get_condition(condition), ": ", col_name, " for ", title_sess, ": Filtered "), 
              subtitle = bquote(list(italic('n')==.(n))), 
              x = "Time [s]", 
              y = label) + 
          theme_bw() + 
          theme(panel.background=element_rect(fill = "NA"), panel.grid.minor = element_line(colour = "#E0E0E0"), 
                plot.title = element_text(size=10)) + 
          scale_x_continuous(breaks = pretty_breaks(n = 4)) 
      
      # We now print the two plots side by side. 
      print(ggarrange(g1, g2, ncol = 2, nrow = 1)) 
      
      # And print a little space between them. 
      cat("  \n    \n    \n  ") 
      
    } 
  } 
} 





# Don't make me explain how this works please. 
figure_out_session <- function(sess) { 
  if (isMatch(sess, 'RestingBaseline')) { 
    return("Resting Baseline") 
  } else if (isMatch(sess, 'BaselineWriting')) { 
    return("Single Task") 
  } else if (isMatch(sess, 'StressCondition')) { 
    return("Break") 
  } else if (isMatch(sess, 'DualTask')) { 
    return("Dual Task") 
  } 
  return(sess) 
} 





# ... or this one... 
figure_out_labels <- function(col_name) { 
  if (isMatch(col_name, 'PP')) { 
    return(bquote(paste('Perinasal Perspiration [',''^'o','C',''^2,']'))) 
  } else if (isMatch(col_name, 'HR')) { 
    return('Heart Rate [BPM]') 
  } else if (isMatch(col_name, 'BR')) { 
    return('Breathing Rate [BPM]') 
  } else if (isMatch(col_name, 'EDA')) { 
    return(expression(paste('EDA [', mu, 'S]'))) 
  } 
  return('Unknown axis.') 
} 





# ... or this one... 
get_condition <- function(condition) { 
  if (isMatch(condition, 'IH')) { 
    return("IF") 
  } else if (isMatch(condition, 'IL')) { 
    return("IN") 
  } else if (isMatch(condition, 'BH')) { 
    return("BF") 
  } else if (isMatch(condition, 'BL')) { 
    return("BN") 
  } 
  return('Unknown condition') 
} 

``` 

```{r echo=FALSE, warning = FALSE, message = FALSE} 
# Whew! We made it! 
# Now we just call the functions we made, sit back, and relax! 
find_subject_sessions() 
circus_wrangler() 
``` 

\newpage  
\vspace*{\fill} 
# Intermittent-Filler (IF) 
\vspace*{\fill} 
\newpage  
```{r echo = FALSE, warning = FALSE, message = FALSE} 
measurements <- c("PP", "HR", "BR", "D.EDA", "D.HR", "N.EDA", "N.HR") 
condition <- "IH" 
for (measure in measurements) { 
  do_the_actual_plotting_now(result_df, measure, condition) 
} 
``` 

\newpage  
\vspace*{\fill} 
# Intermittent-Nothing (IN) 
\vspace*{\fill} 
\newpage  
```{r echo = FALSE, warning = FALSE, message = FALSE} 
condition <- "IL" 
for (measure in measurements) { 
  do_the_actual_plotting_now(result_df, measure, condition) 
} 
``` 

\newpage  
\vspace*{\fill} 
# Batch-Filler (BF) 
\vspace*{\fill} 
\newpage  
```{r echo = FALSE, warning = FALSE, message = FALSE} 
condition <- "BH" 
for (measure in measurements) { 
  do_the_actual_plotting_now(result_df, measure, condition) 
} 
``` 

\newpage  
\vspace*{\fill} 
# Batch-Nothing (BN) 
\vspace*{\fill} 
\newpage  
```{r echo = FALSE, warning = FALSE, message = FALSE} 
condition <- "BL" 
for (measure in measurements) { 
  do_the_actual_plotting_now(result_df, measure, condition) 
} 
``` 

```{r echo = FALSE, warning = FALSE, message = FALSE} 

# We start by creating a `TimeElapsed` column in our global tibble to make this email section easier. 
result_df <- result_df[ , c("Subject", "Condition", "Session", "CovertedTime", "PP", "HR", "BR", "D.EDA", "D.HR", "N.EDA", "N.HR")] 
result_df <- result_df %>% 
  group_by(Subject, Session) %>% 
  mutate(TimeElapsed = as.integer(CovertedTime) - as.integer(head(CovertedTime, 1))) 
# Now we create a now column, `Task`, this is NA for everything except DualTask. When it is DualTask's time, we have the task be essay to show that 
# the subject is writing their essay until we see they have opened the email, which shows they are now writing the email. We will see how exactly this 
# works in the loops below. 
# So, by default, `Task` is NA. 
result_df$Task <- NA 
# We start with the entire DualTask session having a `Task` set to "Essay" then change this below 
result_df[result_df$Session == "DualTask", "Task"] <- "Essay" 

# We go through each of the subjects we have emails for and loop through them. 
subj_list <- levels(factor((result_df$Subject))) 
for (subject in subj_list) { 

  # We isolate just this subject's email times. 
  subj_email_df <- emails_df %>% 
    filter(Subject == subject) 
  
  # If we somehow don't have emails for this subject, set the whole session to NA. 
  if (nrow(subj_email_df) == 0) { 
    result_df[result_df$Subject == subject & result_df$Session == "DualTask", "Task"] <- NA 
  } 
  
  # This is important: there are two email groups - intermittent and high. Intermittent will have eight distinct email opening times paired with 
  # eight distinct email closing times. For each of the eight intervals here, we have to set those times to "Email" 
  condition <- as.character(result_df[result_df$Subject == subject, "Condition"][1, 1]) 
  # Oh, and bad counter serves to count how many emails we have to skip over because the time is 0. If we have 8 bad counters by the end, that means 
  # we skipped over ALL 8 emails for the subject to send, showing that they didn't even write emails at all! So the whole session is 
  # NA just to spite them. 
  bad_counter <- 0 
  if (condition %in% c("IH", "IL")) { 
    for (i in 1:8) { # since there are 8 emails 
      if (is.na(subj_email_df[[i]]) | is.na(subj_email_df[[i + 8]]) | subj_email_df[[i]] == 0 | 
          subj_email_df[[i + 8]] == 0 | subj_email_df[[i]] == subj_email_df[[i + 8]]) { 
        bad_counter <- bad_counter + 1 
        next 
      } 
      result_df[result_df$Subject == subject & result_df$Session == "DualTask" & 
                  subj_email_df[[i]] <= result_df$TimeElapsed & result_df$TimeElapsed <= subj_email_df[[i + 8]], "Task"] <- "Email" 
    } 
    if (bad_counter == 8) { 
      result_df[result_df$Subject == subject & result_df$Session == "DualTask", "Task"] <- NA 
    } 
  # For batch emails, the system is a bit different. Now, we note that a subject opens their first email, answers all eight emails in a row, 
  # then closes the final email. To address this for batch subjects, we go ahead and just find the earliest email opening time and the largest 
  # email closing time, and set all the time in between these two values to "Email". Short, simple, sweet, and easy! NEXT! 
  } else if (condition %in% c("BH", "BL")) { 
    min_time <- apply(subj_email_df[subj_email_df$Subject == subject, 1:16], 1, FUN = min) 
    max_time <- apply(subj_email_df[subj_email_df$Subject == subject, 1:16], 1, FUN = max) 
    if (!is.na(min_time) & !is.na(min_time) & max_time != 0 & min_time != max_time) { 
      result_df[result_df$Subject == subject & result_df$Session == "DualTask" & 
                  min_time <= result_df$TimeElapsed & result_df$TimeElapsed <= max_time, "Task"] <- "Email" 
    } else { 
      result_df[result_df$Subject == subject & result_df$Session == "DualTask", "Task"] <- NA 
    }
  } 
} 

# Now we re-order the columns to an appropriate order... 
result_df <- result_df[ , c("Subject", "Condition", "Session", "CovertedTime", "TimeElapsed", "PP", "HR", "BR", "D.EDA", "D.HR", "N.EDA", "N.HR", "Task")] 
emails_df <- emails_df[ , c("Subject", "Email.1.Open.Email.Time", "Email.2.Open.Email.Time", "Email.3.Open.Email.Time", "Email.4.Open.Email.Time", 
                           "Email.5.Open.Email.Time", "Email.6.Open.Email.Time", "Email.7.Open.Email.Time", "Email.8.Open.Email.Time", 
                           "Email.1.Ending.Time", "Email.2.Ending.Time", "Email.3.Ending.Time", "Email.4.Ending.Time", "Email.5.Ending.Time", 
                           "Email.6.Ending.Time", "Email.7.Ending.Time", "Email.8.Ending.Time")] 

# Last but not least, we write this big ol' global tibble to a .csv file so we can access it for every other script we have to run! 
write.table(result_df, file = "@Datasets/full_df.csv", row.names=F, sep = ',') 
# write.table(result_df, file = "@Datasets/physiological_data.csv", row.names=F, sep = ',') 
# We also write this email dataframe for someone to look at later - who knows?! 
write.table(emails_df, file = "@Datasets/email_df.csv", row.names=F, sep = ',') 

``` 

```{r echo = FALSE, warning = FALSE, message = FALSE} 

## CHANGE THIS! 
# I know it makes no sense to read a dataframe in that we just exported out, but I was having major problems getting the mean values for the `HR` 
# column by using the one above. This is likely due to the structure of the dataframe before it is written to .csv, maybe the `HR` column is set to factor? 
# Hmmm... interesting. Well, challenge to the reader: be less lazy than me in my final week and try to figure this one out! 
# EDIT: figured it out. Why oh why does R set all integer columns to 'character' by default? WHY?! 
measurements <- c("PP", "HR", "BR", "D.EDA", "N.EDA", "D.HR", "N.HR") 
for (measure in measurements) { 
  result_df[[measure]] <- as.numeric(result_df[[measure]]) 
} 
# Now we just add some neat things to each of the too filtered subject dataframes we have and then prepare to merge them. 
subjects_we_filtered$Explaination <- "Filtered in AllSignals" 

# Cool, we just merged them together into one super-special `subjects_we_filtered` dataframe. So cool, right?! Let's keep going! 
if (nrow(subjects_we_filtered) > 0) { 
  subjects_we_filtered <- unique(rbind(discarded_df, subjects_we_filtered)) 
} else { 
  subjects_we_filtered <- unique(discarded_df) 
} 

# So to get this `subject_summary` dataframe correct, we have to determine three things: 
# 1) Was the signal missing? If so, we give it a 0. 
# 2) Was the signal filtered out? If so, we give it a -1. 
# 3) If none of the above, the signal must have been valid, so we give it a 1. 
# The easiest way to get this done is to find the mean for each session for each subject with `na.rm` set to TRUE. 
# This way, all NA columns will stay NA and columns with some NAs will still be kept in a numeric value! Great, right? 
subject_summary <- result_df[ , !names(result_df) %in% c("TimeElapsed", "CovertedTime", "Task")] %>% 
  group_by(Subject,	Session, Condition) %>% 
  summarize_all(mean, na.rm = TRUE) %>% 
  ungroup() 

subject_summary <- as.tibble(subject_summary) 

# Now we check: for each of the `measurements` columns, if it's not NA, set it to 1. 
for (measure in measurements) { 
  subject_summary[!is.na(subject_summary[[measure]]), measure] <- 1 
} 
# If anything is NA, set it to 0 (for now). Some of these NAs might be filtered out signals that got turned NA but weren't missing, 
# so right below this line, we will address that. 

subject_summary[is.na(subject_summary)] <- 0 

# Okay, so everything here is pretty simple. We search through the `subjects_we_filtered` dataframe we assembled earlier and see if we have 
# a specific subject in there. If we do, for each session we have a measurement value, we set it to -1 in the `subject_summary` dataframe. 
# Clean, simple, done! 
for (subj_name in levels(factor(subject_summary$Subject))) { 
  for (measure in measurements) { 
    specific_subject_filter_measure_combo <- subjects_we_filtered %>% 
      filter(Measure == measure) 
    
    do_we_have_anything_now <- specific_subject_filter_measure_combo %>% 
      filter(Subject == subj_name) 
    
    if (nrow(do_we_have_anything_now) > 0) { 
      subject_summary[subject_summary$Subject == subj_name & subject_summary$Session %in% do_we_have_anything_now$Session, measure] <- -1 
    } 
  } 
} 

for (subj_name in unique(subjects_we_filtered$Subject)) { 
  if (!(subj_name %in% subject_summary$Subject)) { 
    subject_summary <- rbind(subject_summary, tibble("Subject" = subj_name, 
                                                     "Session"	= c("RestingBaseline", "BaselineWriting", "StressCondition", "DualTask", "Presentation"), 
                                                     "Condition"	= -1, "PP" = -1, "HR" = -1, "BR" = -1, "D.EDA" = -1, "D.HR" = -1, "N.EDA"	= -1, "N.HR" = -1)) 
  } 
} 

subject_summary <- subject_summary %>% 
  mutate(Session = factor(Session, levels = c("RestingBaseline", "BaselineWriting", "StressCondition", "DualTask", "Presentation"))) %>% 
  arrange(Subject, Session) 

subject_summary <- rbind(subject_summary, tibble("Subject" = paste0("TOTAL: ", length(unique(subject_summary$Subject))), 
                                                 "Session"	= "-----", 
                                                 "Condition"	= "--", 
                                                 "PP" = sum(subject_summary$PP == 1), 
                                                 "HR" = sum(subject_summary$HR == 1), 
                                                 "BR" = sum(subject_summary$BR == 1), 
                                                 "D.EDA" = sum(subject_summary$D.EDA == 1), 
                                                 "D.HR" = sum(subject_summary$D.HR == 1), 
                                                 "N.EDA"	= sum(subject_summary$N.EDA == 1), 
                                                 "N.HR" = sum(subject_summary$N.HR == 1))) 

subjects_we_filtered <- subjects_we_filtered %>% 
  mutate(Session = factor(Session, levels = c("RestingBaseline", "BaselineWriting", "StressCondition", "DualTask", "Presentation"))) %>% 
  arrange(Subject, Session) 

subject_summary$IRB <- "Unknown" 

# And then, just for kicks, we write THESE dataframes to .csv files too because why not overflow the reader with TOO much information! 
write.table(subject_summary, file = "@Datasets/subject_summary.csv", row.names=F, sep = ',') 
write.table(subjects_we_filtered, file = "@Datasets/subjects_we_filtered.csv", row.names=F, sep = ',') 

``` 
